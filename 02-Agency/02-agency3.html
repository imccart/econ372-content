<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Module 2: Physician Agency and Treatment Decisions</title>
    <meta charset="utf-8" />
    <meta name="author" content="Ian McCarthy, Emory University" />
    <link href="libs/remark-css/default.css" rel="stylesheet" />
    <link href="libs/remark-css/metropolis.css" rel="stylesheet" />
    <link href="libs/remark-css/metropolis-fonts.css" rel="stylesheet" />
    <link rel="stylesheet" href="custom.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Module 2: Physician Agency and Treatment Decisions
## Agency and capitated payments
### Ian McCarthy, Emory University
### Econ 372, Spring 2021

---


&lt;!-- Adjust some CSS code for font size and maintain R code font size --&gt;
&lt;style type="text/css"&gt;
.remark-slide-content {
    font-size: 30px;
    padding: 1em 2em 1em 2em;    
}
.remark-code, .remark-inline-code { 
    font-size: 20px;
}
&lt;/style&gt;


&lt;!-- Set R options for how code chunks are displayed and load packages --&gt;


# What are "capitated" payments?

- Payments for a person or group
- Set amount intended to cover all expenses for a given person/group
- If expenses exceed that amount, the providers lose money
- If expenses fall below that amount, the providers make a profit

---
# Examples of capitated payments

- No "fully capitated" payments in the U.S.
- Closest in the U.S. is an "accountable care organization"
- More common in UK, Canada, and other public systems

--

- We'll discuss more in the next section of this module

---
# Incentives

Thinking about FFS versus capitated payments...

- What are the incentives in a FFS model if the goal is to make more money?
- Are those incentives different in a capitated payment model? How?

---
# Agency with capitated payments

- Physician receives fixed ("capitated") amount for each patient, `\(R\)`, along with some price per unit of service, `\(p_{s}\)`

- Physician therefore paid `\(R + (p_{s} - c)x\)` for each patient

- Number of patients for each physician expressed as a positive function of the net benefit offered, `\(n(NB)\)`, where `\(NB=B(x) - p_{d}x\)`. Here, we assume that the insurer sets `\(p_{d}\)` and `\(p_{s}\)` separately (the demand and supply price, respectively).

- Physician again aims to maximize profits, `\(\pi=n(NB)\left[R+(p_{s}-c)x\right]\)`.


---
# Solution with capitated payments
Maximizing the profit function yields:&lt;br&gt;
`\(n'(NB)(B'(x) - p_{d}) \left[R + (p_{s} - c)x \right] + n(NB)(p_{s}-c) = 0\)`.&lt;br&gt;

Rearranging terms and multiplying both sides by `\(\frac{1}{NB}\)`, we get:&lt;br&gt;
`\(\frac{B'(x) - p_{d}}{NB} \frac{R + (p_{s} - c)x}{p_{s}-c} = - \frac{1}{\varepsilon_{n,NB}}\)`

--

1. What happens for `\(R=0\)`?
2. What about `\(R&gt;0\)`, assuming `\(p_{s}&lt;c\)`?

---
# In-class problem: Agency and Capitated Payments

- Assume that the physician's number of patients in the practice depends on the net benefit offered, `\(NB=B(x) - p_{d}x\)`, where `\(x\)` denotes the amount of care and `\(p_{d}\)` denotes the prices that the patient must pay. For simplicity, we'll assume that the number of patients is the same as the net benefit, `\(n(NB) = NB\)`.
- Assume that patients are fully insured so that `\(p_{d}=0\)`. 
- Assume that the benefit function is `\(B(x) = 16x-2x^{2}\)`. 
- Assume that the physician is paid a fixed amount, `\(R\)`, for each patient, and earns some profit, `\(p_{s}-c\)`, on each unit of care.

---
count: false

# In-class problem: Agency and Capitated Payments

1. Solve for the patient's optimal amount of care (if they could choose the amount on their own).
2. Write out the physician's profit function based on the information provided.
3. Find the physician's optimal `\(x\)` if `\(R=0\)` and `\(p_{s}-c=1\)`.
4. Find the physician's optimal `\(x\)` if `\(R=1\)` and `\(p_{s}-c=1\)`. How does this differ from part (3)?
5. Find the physician's optimal `\(x\)` if `\(R=1\)` and `\(p_{s}-c=0\)`.



---
# Takeaways
Excessive treatment may arise because physicians can choose a level of care, and this choice may derive from incentives that are not perfectly aligned with those of the patients. From this section, you should be able to:&lt;br&gt;

1. Set up and solve the physician's optimization problem and compare the solution to that of the patient's optimum.
2. Show mathematically how the design of an insurance contract (namely, capitated payments versus fee-for-service payments) may determine the extent to which physicians overprovide care.
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script src="macros.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false,
"ratio": "16:9"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
